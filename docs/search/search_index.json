{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/actor/discovery.html","text":"","title":"发现其它actor"},{"location":"/actor/discovery.html#发现其它actor","text":"TODO","title":"发现其它actor"},{"location":"/actor/shutdown.html","text":"","title":"怎样优雅的关闭 ActorSystem"},{"location":"/actor/shutdown.html#怎样优雅的关闭-actorsystem","text":"TODO","title":"怎样优雅的关闭 ActorSystem"},{"location":"/actor/lifecycle.html","text":"","title":"生命周期"},{"location":"/actor/lifecycle.html#生命周期","text":"TODO","title":"生命周期"},{"location":"/index.html","text":"","title":"Akka Cookbook"},{"location":"/index.html#akka-cookbook","text":"提供清晰、实用的Akka应用指导\n在线阅读：https://www.yangbajing.me/akka-cookbook/ 。\n从Akka 2.6开始，Typed 已经作为默认实现，本书也将基于 typed actor 讲解有关Akka的各种知识。同时，本书示例都将使用 Scala 2.13 完成。可以在 https://github.com/yangbajing/akka-cookbook 找到本书的所有示例及源文件。","title":"Akka Cookbook"},{"location":"/index.html#目录","text":"Actor 介绍 通过 ActorSystem 创建 actor 怎样优雅的停止actor 处理 actor 异常 请求-响应模式 适配响应类型到 actor Actor之间使用请求-响应模式 Akka 流（Streams） 访问文件 访问FTP/sFTP 访问存储 使用JDBC访问关系数据库 访问 Cassandra 访问 MongoDB 访问 Elasticsearch 集成 Spring Web & Akka Streams Akka HTTP Akka 集群 Akka 持久化","title":"目录"},{"location":"/actor/index.html","text":"","title":"Actor"},{"location":"/actor/index.html#actor","text":"https://doc.akka.io/docs/akka/current/typed/\n介绍 HelloWorld Behavior ActorRef 构造 ActorSystem 通过 ActorSystem 创建 actor 使用 SpawnProtocol 为守卫actor提供自定义 Spawn 消息 怎样优雅的停止actor 返回 Behaviors.stopped Graceful Stop 处理 actor 异常 监管策略 错误（Validation Error）与失败（Failure） 示例 请求-响应模式 适用范围 问题 适配响应类型到 actor 适用范围 问题 Actor之间使用请求-响应模式 适用范围 问题 完整代码\nlifecycle discovery shutdown","title":"Actor"},{"location":"/actor/introduction.html","text":"","title":"介绍"},{"location":"/actor/introduction.html#介绍","text":"","title":"介绍"},{"location":"/actor/introduction.html#helloworld","text":"第一个示例是一个 Ping-Pong，从一个actor发送消息到另一个actor，并收到回复。\nobject Ping {\n  sealed trait Command\n  final case object Start extends Command\n  final case class PongCommand(message: String) extends Command\n  def apply(): Behavior[Command] = Behaviors.receive {\n    case (context, Start) =>\n      val pong = context.spawn(Pong(), \"pong\")\n      pong ! Pong.PingCommand(\"Scala\", context.self)\n      context.log.info(\"Started Pong actor and send message complete.\")\n      Behaviors.same\n    case (context, PongCommand(message)) =>\n      context.log.info(s\"Receive pong message: $message\")\n      Behaviors.stopped\n  }\n}\n\nobject Pong {\n  sealed trait Command\n  final case class PingCommand(message: String, replyTo: ActorRef[Ping.Command]) extends Command\n  def apply(): Behavior[Command] = Behaviors.receive[Command] {\n    case (context, PingCommand(message, replyTo)) =>\n      context.log.info(s\"Receive ping message: $message\")\n      replyTo ! Ping.PongCommand(s\"Hello $message\")\n      Behaviors.stopped\n  }\n}\n运行actor需要有一个ActorSystem，这面的代码将执行这个示例。\nval system: ActorSystem[Ping.Command] = ActorSystem(Ping(), \"helloworld\")\nsystem ! Ping.Start\nsystem.terminate()\n运行示例程序，可看到如何输出：\nsbt:akka-cookbook> cookbook-actor/runMain cookbook.actor.introduction.HelloWorld\n[info] running (fork) cookbook.actor.introduction.HelloWorld \n[2019-11-19 19:24:39,285] [INFO] [akka.event.slf4j.Slf4jLogger] [helloworld-akka.actor.default-dispatcher-3] [] - Slf4jLogger started\n[2019-11-19 19:24:39,374] [INFO] [cookbook.actor.introduction.Ping$] [helloworld-akka.actor.default-dispatcher-3] [akka://helloworld/user] - Started Pong actor and send message complete.\n[2019-11-19 19:24:39,374] [INFO] [cookbook.actor.introduction.Pong$] [helloworld-akka.actor.default-dispatcher-6] [akka://helloworld/user/pong] - Receive ping message: Scala\n[2019-11-19 19:24:39,375] [INFO] [cookbook.actor.introduction.Ping$] [helloworld-akka.actor.default-dispatcher-3] [akka://helloworld/user] - Receive pong message: Hello Scala\n[success] Total time: 1 s, completed Nov 19, 2019 19:24:39 PM","title":"HelloWorld"},{"location":"/actor/introduction.html#behavior","text":"Akka Typed使用Behavior[T]（ 行为 ）替代了经典（Untyped）actor的Actor特质。每次actor被调用后都需要返回一个新的行为以待下一次actor被执行时调用。Behavior更明确的表达出actor是由一系列响应消息的行为组成，它可以是一个纯函数（ 就像示例一样，Behavior由函数创建，它关不需要定义一个类 ），也可以拥有状态……","title":"Behavior"},{"location":"/actor/introduction.html#actorref","text":"ActorRef[T]是Behavior[T]被ActorSystem构造后创建的actor的引用，与经典ActorRef的区别显而易见，它拥有了一个类型参数T，T限定了这个actor只能处理T或它的子类型。这相对经典actor是一大进步，特别是在你的actor系统规模很大时，若没有一个静态的类型约束你将十之八九会迷失在消息的海洋……","title":"ActorRef"},{"location":"/actor/introduction.html#构造-actorsystem","text":"ActorSystem构造至少需要转入两个参数：\nguardianBehavior: Behavior[T]：守卫行为，它将被创建为守卫actor，其 ActorPath 地址为：akka://helloworld/user。 name: String：ActorSystem名字，这个名字除了在日志线程中显示外，在Akka Cluster时也很重要，用于标识同一个集群。","title":"构造 ActorSystem"},{"location":"/actor/create-actor-externally.html","text":"","title":"通过 ActorSystem 创建 actor"},{"location":"/actor/create-actor-externally.html#通过-actorsystem-创建-actor","text":"Akka Typed已不允许通过 ActorSystem 的实例来创建actor，推荐自定义的根actor来初始化整个actor树，并在构建 ActorSystem 作为守卫行为传入：\nval behavior: Behavior[T] = _ // 根actor，用于构建整个actor业务树\nval system = ActorSystem(behavior, \"typed\")\n但实际应用中，允许有充分的理由需要通过 ActorSystem 来创建actor，这有两种方式：\n使用 SpawnProtocol 为守卫actor提供自定义 Spawn 消息","title":"通过 ActorSystem 创建 actor"},{"location":"/actor/create-actor-externally.html#使用-spawnprotocol","text":"implicit val system = ActorSystem(SpawnProtocol(), \"spawn-protocol\")\nimplicit val timeout = Timeout(2.seconds)\nval pingF = system.ask[ActorRef[Ping.Command]](replyTo => SpawnProtocol.Spawn(Ping(), \"ping\", Props.empty, replyTo))\nval ping = Await.result(pingF, 2.seconds)\nping ! Ping.Start\nsystem.terminate()\n将Akka内置的SpawnProtocol作为ActorSystem的初始化行为，就可以通过SpawnProtocol.Spawn消息来创建actor。","title":"使用 SpawnProtocol"},{"location":"/actor/create-actor-externally.html#为守卫actor提供自定义-消息","text":"使用SpawnProtocol虽然可以在ActorSystem外部创建actor，但却没法使用我们自己定义的守卫actor了。参照 SpawnProtocol.Spawn 为自己的守卫actor提供Spawn消息，这样就可以在ActorSystem外部创建actor了。\nobject RootActor {\n  sealed trait Command\n  case class Spawn[T](behavior: Behavior[T], name: String, props: Props, replyTo: ActorRef[ActorRef[T]]) extends Command\n  // 在此添加其它业务消息\n\n  def apply(): Behavior[Command] = Behaviors.receive {\n    case (context, Spawn(behavior, name, props, replyTo)) =>\n      replyTo ! context.spawn(behavior, name, props)\n      Behaviors.same\n  }\n}\n通过此方式创建的所以actor都为是守卫actor的子actor。","title":"为守卫actor提供自定义 Spawn 消息"},{"location":"/actor/stop.html","text":"","title":"怎样优雅的停止actor"},{"location":"/actor/stop.html#怎样优雅的停止actor","text":"","title":"怎样优雅的停止actor"},{"location":"/actor/stop.html#返回-behaviors-stopped","text":"每处理一个消息，actor都将返回一个行为，可以通过返回 Behaviors.stopped 行为来告诉ActorSystem此actor应被自动停止。\ncase (context, Stop) =>\n  context.log.info(s\"Receive message: $Stop, will stopped.\")\n  Behaviors.stopped\nBehaviors.stopped被执行时将触发 PostStop 信号。","title":"返回 Behaviors.stopped"},{"location":"/actor/stop.html#graceful-stop","text":"通常，PostStop信号被作为非正常停止看待，若想在正常停止（Graceful Stop）时触发一些清理操作，可将清理函数（cleanup）传给Behaviors.stopped的重载版本。\ncase (context, GracefulStop) =>\n  context.log.info(s\"Receive message: $GracefulStop, will stopped.\")\n  Behaviors.stopped(() => cleanup(context.log))\n当 PostStop 信号被处理后，cleanup清理函数将紧接着执行。\ndef cleanup(log: Logger): Unit = {\n  log.info(\"Perform cleanup action.\")\n}","title":"Graceful Stop"},{"location":"/actor/supervise.html","text":"","title":"处理 actor 异常"},{"location":"/actor/supervise.html#处理-actor-异常","text":"Akka实现了 Let it crash 模式，它假定失败是不可避免的。我们不应该花费过多的精力去设计一个永不失败的系统，而是假定失败在所难免，当失败发生时应快速的响应失败并以正确的状态重新启动。","title":"处理 actor 异常"},{"location":"/actor/supervise.html#监管策略","text":"通过Akka的监控机制，我们可以在actor发生异常时对其拦截并进行处理。默认的监管策略有：\nresume：忽略失败，并继续处理下一条消息（如果有） restart：重启actor stop：停止actor， 这是typed actor的默认行为，而untyped actor默认是重启","title":"监管策略"},{"location":"/actor/supervise.html#错误-validation-error-与失败-failure-","text":"但我们应该在发生任何异常时都应用Akka的监管策略吗？答案是否定的。对于错误（验证错误）与失败，两者之间有显著区别：\nValidation Error：验证错误通常是业务逻辑的一部分，不应该抛出异常！而应该建模的actor协议（消息）； Failure：对于 失败，应用 让它崩溃 模式是有用的。以一个干净地、可预测的全新状态恢复运行比通过大量的逻辑判断和try catch语句而污染了代码更有效。","title":"错误（Validation Error）与失败（Failure）"},{"location":"/actor/supervise.html#示例","text":"case class RestartException(message: String) extends RuntimeException(message)\ncase class StopException(message: String) extends RuntimeException(message)\n\nsealed trait Command\nfinal case object Message extends Command\nfinal case object Restart extends Command\nfinal case object Stop extends Command\n\ndef apply(): Behavior[Command] = Behaviors.setup { context =>\n  println(s\"${context.self} started.\")\n  Behaviors\n    .receiveMessage[Command] {\n      case Message =>\n        println(s\"${context.self} Received Message.\")\n        Behaviors.same\n      case Restart =>\n        throw RestartException(\"可重启\")\n      case Stop =>\n        throw StopException(\"退出\")\n    }\n    .receiveSignal {\n      case (context, PreRestart) =>\n        println(s\"${context.self} Received signal $PreRestart\")\n        Behaviors.same\n      case (context, PostStop) =>\n        println(s\"${context.self} Received signal $PostStop\")\n        Behaviors.same\n    }\n}\n通过Behaviors.supervise来包裹 behavior 来实现监管策略。多个监管策略可以使用Behaviors.supervise嵌套来实现。\nBehaviors\n  .supervise(Behaviors.supervise(FaultTolerance()).onFailure[RestartException](SupervisorStrategy.restart))\n  .onFailure[StopException](SupervisorStrategy.stop)\n运行示例输出内容如下（隐藏了部分日志输出）：\nActor[akka://fault-tolerance/user#0] started.\nActor[akka://fault-tolerance/user#0] Received Message.\nActor[akka://fault-tolerance/user#0] Received signal PreRestart\n[2019-11-19 19:51:48,105] [ERROR] [akka.actor.typed.Behavior$] [fault-tolerance-akka.actor.default-dispatcher-3] [akka://fault-tolerance/user] - Supervisor RestartSupervisor saw failure: 可重启\n....\nActor[akka://fault-tolerance/user#0] started.\n[2019-11-19 19:51:49,070] [ERROR] [akka.actor.LocalActorRefProvider(akka://fault-tolerance)] [fault-tolerance-akka.actor.default-dispatcher-3] [akka.actor.LocalActorRefProvider(akka://fault-tolerance)] - guardian failed, shutting down system\n....\n[2019-11-19 19:51:49,071] [ERROR] [akka.actor.OneForOneStrategy] [fault-tolerance-akka.actor.default-dispatcher-3] [akka://fault-tolerance/user] - 退出\n....\nActor[akka://fault-tolerance/user#0] Received signal PostStop","title":"示例"},{"location":"/actor/request-response.html","text":"","title":"请求-响应模式"},{"location":"/actor/request-response.html#请求-响应模式","text":"请求-响应是很经典的一个模式，Ping-Pong就是一个典型的请求响应模式的应用。其完整代码如下：\nsealed trait Command\nfinal case object Start extends Command\nfinal case class PongCommand(message: String) extends Command\ndef apply(): Behavior[Command] = Behaviors.receive {\n  case (context, Start) =>\n    val pong = context.spawn(Pong(), \"pong\")\n    pong ! Pong.PingCommand(\"Scala\", context.self)\n    context.log.info(\"Started Pong actor and send message complete.\")\n    Behaviors.same\n  case (context, PongCommand(message)) =>\n    context.log.info(s\"Receive pong message: $message\")\n    Behaviors.stopped\n}","title":"请求-响应模式"},{"location":"/actor/request-response.html#适用范围","text":"订阅actor并希望收到被订阅actor响应的多个消息","title":"适用范围"},{"location":"/actor/request-response.html#问题","text":"响应消息也许不匹配请求actor的类型限制，（参阅：适配响应 获取解决方案） 很难检测到请求是否送达或已被处理 当请求actor发起多次请求时，不能保存请求上下文信息（可在消息内加上请求id或引入新的独立接收者可解决此问题）","title":"问题"},{"location":"/actor/adapted-response.html","text":"","title":"适配响应类型到 actor"},{"location":"/actor/adapted-response.html#适配响应类型到-actor","text":"通常情况下，发送actor的消息类型与接收actor的响应消息类型不匹配（不然就会退化成大部分actor都继承同一个trait，这样就失去了 Typed 的意义！）。这种情况下，我们提供一个正确类型的ActorRef[T]，并将接收actor返回的响应消息T包装成发送actor可以处理的类型。\n先定义一个消息包装类：\nsealed trait Command\nprivate final case class WrappedBackendResponse(response: Backend.Response) extends Command\n消息适配器代码：\nval backendAdapter = context.messageAdapter[Backend.Response](resp => WrappedBackendResponse(resp))\n应该为不同的消息类型注册独立的消息适配器，同一个消息类型多次注册的消息适配器只有最后一个生效。\n如果响应的消息类与给定消息适配器匹配或是其消息适配器消息类型的子类型，则使用它。若有多个消息适配器符合条件，则将选用最后注册的那个。\n消息适配器（context.messageAdapter返回的ActorRef[T]）的生命周期同context所在actor。建议在Behaviors.step或AbstractBehavior构造函数中注册适配器，但也可以在稍后注册它们。\n注册适配器时提供的消息映射函数（resp => WrappedBackendResponse(resp)）在actor中运行，可安全的访问其（actor）内部状态。 但注意不能抛出异常，否则actor将被停止！","title":"适配响应类型到 actor"},{"location":"/actor/adapted-response.html#适用范围","text":"在不同的actor消息协议间进行转换 订阅响应消息的actor，并将响应转换成发送actor可接收的类型","title":"适用范围"},{"location":"/actor/adapted-response.html#问题","text":"难以检测消息是否送达或已被处理 每个响应消息只能进行一次自适应，如果注册了新的适配器则旧的将被替换。如果不同的目标actor使用相同的响应类型，则它们自动选择哪个适配器更合适。这需要在消息中编码某种相关性来解决 除非协议已经包含提供上下文的方法，例如在响应中返回发送的请求ID。否则交互就不能绑定到某个上下文中。","title":"问题"},{"location":"/actor/actor-req-resp.html","text":"","title":"Actor之间使用请求-响应模式"},{"location":"/actor/actor-req-resp.html#actor之间使用请求-响应模式","text":"当请求与响应之间存在1:1映射时，可以通过调用ActorContext[T]上的ask函数来与另一个actor进行交互。\n构造一个传出消息，它使用context.ask[Response]提供的ActorRef[Response]作为接收响应的actor放入消息中将成功/失败（Try[Response]）转换为发送者actor可接收的消息类型\nobject Ping {\n  sealed trait Request\n  private final case class WrappedResponse(response: Pong.Response) extends Request\n  def apply(latch: CountDownLatch): Behavior[Request] = Behaviors.setup { context =>\n    implicit val timeout: Timeout = 2.seconds\n    val pong = context.spawn(Pong(), \"pong\")\n    context.watch(pong)\n    context.ask(pong, (replyTo: ActorRef[Pong.Response]) => Pong.Message(\"Hello Scala!\", 1, replyTo)) {\n      case Success(value)     => WrappedResponse(value)\n      case Failure(exception) => throw exception\n    }\n\n    Behaviors\n      .receiveMessage[Request] {\n        case WrappedResponse(Pong.Result(message, count)) =>\n          context.log.info(s\"Received pong response: $message, ${count}th.\")\n          context.ask[Pong.Request, Pong.Response](pong, Pong.Message(message, count + 1, _)) {\n            case Success(value)     => WrappedResponse(value)\n            case Failure(exception) => throw exception\n          }\n          Behaviors.same\n      }\n      .receiveSignal {\n        case (_, Terminated(`pong`)) =>\n          context.log.info(s\"Actor $pong be terminated.\")\n          latch.countDown()\n          Behaviors.stopped\n      }\n  }\n}\ncontext.ask的响应映射函数在接收actor中运行，可以安全的访问actor内部状态， 但抛出异常的话actor将会被停止 。\noverride def ask[Req, Res](target: RecipientRef[Req], createRequest: ActorRef[Res] => Req)(\n      mapResponse: Try[Res] => T)(implicit responseTimeout: Timeout, classTag: ClassTag[Res]): Unit = {\n    import akka.actor.typed.scaladsl.AskPattern._\n    pipeToSelf((target.ask(createRequest))(responseTimeout, system.scheduler))(mapResponse)\n  }\n\n  def pipeToSelf[Value](future: Future[Value])(mapResult: Try[Value] => T): Unit = {\n    future.onComplete(value => self.unsafeUpcast ! AdaptMessage(value, mapResult))\n  }\n上面是context.ask函数实现：\ntarget：接收actor引用 createRequest：创建请求消息函数，参数是ask创建的临时actor，此临时actor用于适配接收actor的消息类型 mapResponse：将获取的响应消息类型Res映射成请求actor可以接收的消息类型\n可以看到，context.ask函数实际上是在目标actor（target）上调用了ask方法，并将返回的Future[T]结果转换并发送到context所在的actor。","title":"Actor之间使用请求-响应模式"},{"location":"/actor/actor-req-resp.html#适用范围","text":"单个查询响应的转换 发送actor需要在继续之前知道消息已被处理（通过context.ask(..., ...)(mapResponse)的mapResponse函数） 如果请求超时，允许actor重新发送消息（通过mapResponse回调函数里处理） 跟踪未完成的请求 保存上下文。发送者actor接收的请求有上下文信息（context.ask将生成一个临时actor，这个临时actor即可作为一个确定上下文的载体），如：请求ID reqId，而后端协议不支持这个参数时","title":"适用范围"},{"location":"/actor/actor-req-resp.html#问题","text":"一个ask只能有一个响应（因为ask会创建一个临时actor，这个actor在收到响应后就会结束自己） 当请求超时时，接收actor（发回响应的那个）并不知道且仍可能将请求处理并完成，甚至若接收actor很忙的话会在请求超时发生以后再处理它 为超时情况找到一个好的（包装）值，特别是在ask函数调用后还会触发链式调用时（一个异步调用完成后进行另一个异步调用）。这时候希望来快速响应超时情况并回复请求者，但同时需要避免误报。","title":"问题"},{"location":"/actor/actor-req-resp.html#完整代码","text":"/*\n * Copyright 2019 yangbajing.me\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cookbook.actor.pingpong\n\nimport java.util.concurrent.CountDownLatch\n\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ ActorRef, ActorSystem, Behavior, Terminated }\nimport akka.util.Timeout\n\nimport scala.concurrent.duration._\nimport scala.util.{ Failure, Success }\n\nobject Ping {\n  sealed trait Request\n  private final case class WrappedResponse(response: Pong.Response) extends Request\n  def apply(latch: CountDownLatch): Behavior[Request] = Behaviors.setup { context =>\n    implicit val timeout: Timeout = 2.seconds\n    val pong = context.spawn(Pong(), \"pong\")\n    context.watch(pong)\n    context.ask(pong, (replyTo: ActorRef[Pong.Response]) => Pong.Message(\"Hello Scala!\", 1, replyTo)) {\n      case Success(value)     => WrappedResponse(value)\n      case Failure(exception) => throw exception\n    }\n\n    Behaviors\n      .receiveMessage[Request] {\n        case WrappedResponse(Pong.Result(message, count)) =>\n          context.log.info(s\"Received pong response: $message, ${count}th.\")\n          context.ask[Pong.Request, Pong.Response](pong, Pong.Message(message, count + 1, _)) {\n            case Success(value)     => WrappedResponse(value)\n            case Failure(exception) => throw exception\n          }\n          Behaviors.same\n      }\n      .receiveSignal {\n        case (_, Terminated(`pong`)) =>\n          context.log.info(s\"Actor $pong be terminated.\")\n          latch.countDown()\n          Behaviors.stopped\n      }\n  }\n}\n\nobject Pong {\n  sealed trait Request\n  final case class Message(message: String, count: Int, replyTo: ActorRef[Response]) extends Request\n  sealed trait Response\n  final case class Result(message: String, count: Int) extends Response\n  def apply(): Behavior[Request] = Behaviors.receive {\n    case (context, Message(message, 100, _)) =>\n      context.log.info(s\"Receiving 100th Ping message: $message, it will stop.\")\n      Behaviors.stopped\n    case (_, Message(message, count, replyTo)) =>\n      replyTo ! Result(message, count)\n      Behaviors.same\n  }\n}\n\nobject PingPongMain {\n  def main(args: Array[String]): Unit = {\n    val latch = new CountDownLatch(1)\n    val system = ActorSystem(Ping(latch), \"ping-pong\")\n    latch.await()\n    system.terminate()\n  }\n}","title":"完整代码"},{"location":"/streams/index.html","text":"","title":"Akka 流（Streams）"},{"location":"/streams/index.html#akka-流-streams-","text":"访问文件 访问FTP/sFTP","title":"Akka 流（Streams）"},{"location":"/streams/file.html","text":"","title":"访问文件"},{"location":"/streams/file.html#访问文件","text":"TODO","title":"访问文件"},{"location":"/streams/ftp.html","text":"","title":"访问FTP/sFTP"},{"location":"/streams/ftp.html#访问ftp-sftp","text":"","title":"访问FTP/sFTP"},{"location":"/storage/index.html","text":"","title":"访问存储"},{"location":"/storage/index.html#访问存储","text":"使用JDBC访问关系数据库 访问 Cassandra 访问 MongoDB 访问 Elasticsearch","title":"访问存储"},{"location":"/storage/jdbc.html","text":"","title":"使用JDBC访问关系数据库"},{"location":"/storage/jdbc.html#使用jdbc访问关系数据库","text":"TODO","title":"使用JDBC访问关系数据库"},{"location":"/storage/cassandra.html","text":"","title":"访问 Cassandra"},{"location":"/storage/cassandra.html#访问-cassandra","text":"TODO","title":"访问 Cassandra"},{"location":"/storage/mongodb.html","text":"","title":"访问 MongoDB"},{"location":"/storage/mongodb.html#访问-mongodb","text":"TODO","title":"访问 MongoDB"},{"location":"/storage/elasticsearch.html","text":"","title":"访问 Elasticsearch"},{"location":"/storage/elasticsearch.html#访问-elasticsearch","text":"TODO","title":"访问 Elasticsearch"},{"location":"/integration/index.html","text":"","title":"集成"},{"location":"/integration/index.html#集成","text":"将Akka与第3方框架、应该集成。\nSpring Web & Akka Streams","title":"集成"},{"location":"/integration/spring-web.html","text":"","title":"Spring Web & Akka Streams"},{"location":"/integration/spring-web.html#spring-web-akka-streams","text":"TODO","title":"Spring Web & Akka Streams"},{"location":"/http/index.html","text":"","title":"Akka HTTP"},{"location":"/http/index.html#akka-http","text":"请访问外部链接阅读： 《Scala Web 开发——基于 Akka HTTP》 。","title":"Akka HTTP"},{"location":"/cluster/index.html","text":"","title":"Akka 集群"},{"location":"/cluster/index.html#akka-集群","text":"","title":"Akka 集群"},{"location":"/persistence/index.html","text":"","title":"Akka 持久化"},{"location":"/persistence/index.html#akka-持久化","text":"","title":"Akka 持久化"}]}